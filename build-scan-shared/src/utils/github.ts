import * as github from '@actions/github'
import {GitHub} from '@actions/github/lib/utils'
import {OctokitResponse} from '@octokit/types' // eslint-disable-line import/named
import * as core from '@actions/core'
import {Artifact, DefaultArtifactClient} from '@actions/artifact'

import * as input from '../input'
import * as io from './io'

const ZIP_EXTENSION = 'zip'

const COMMENT_SIGNATURE = '###### Generated by gradle/develocity-actions'

export function getOctokit(): InstanceType<typeof GitHub> {
    return github.getOctokit(input.getGithubToken())
}

export function isPublicationAllowed(authorizedUsersList: string): boolean {
    return isEventSupported() && isUserAuthorized(authorizedUsersList)
}
function isEventSupported(): boolean {
    return github.context.eventName === 'workflow_run' || isUnderTest()
}

function isUnderTest(): boolean {
    // Some end-to-end tests are run on the pull_request workflow and requires some special treatment
    return (
        github.context.eventName === 'pull_request' &&
        github.context.repo.owner === 'gradle' &&
        github.context.repo.repo === 'github-actions'
    )
}

function getRunActor(): string {
    return isUnderTest() ? getRunActorForTest() : getRunActorForWorkflowRun()
}

function getRunActorForWorkflowRun(): string {
    return github.context.payload.workflow_run.actor.login
}

function getRunActorForTest(): string {
    return github.context.actor
}

function getListArtifactsOptions(): any {
    return isUnderTest() ? getListArtifactsOptionsForTest() : getListArtifactsOptionsForWorkflowRun()
}

function getListArtifactsOptionsForWorkflowRun(): any {
    const runId = github.context.payload.workflow_run.id

    return {
        findBy: {
            token: input.getGithubToken(),
            workflowRunId: runId,
            repositoryName: github.context.repo.repo,
            repositoryOwner: github.context.repo.owner
        }
    }
}

function getListArtifactsOptionsForTest(): any {
    return {
        latest: true
    }
}

export async function getArtifactIdsForWorkflowRun(artifactName: string): Promise<number[]> {
    const artifactClient = new DefaultArtifactClient()

    const artifacts = await artifactClient.listArtifacts(getListArtifactsOptions())

    return getBuildScanArtifactIds(artifactName, artifacts?.artifacts)
}

function isUserAuthorized(authorizedUsersList: string): boolean {
    const prSubmitter = getRunActor()

    core.debug(`prSubmitter = ${prSubmitter}`)
    if (authorizedUsersList && !authorizedUsersList.split(',').includes(prSubmitter)) {
        core.info(`user ${prSubmitter} not authorized to publish Build Scans`)
        return false
    }

    return true
}

export async function downloadBuildScanData(artifactName: string, develocityDir: string): Promise<number[]> {
    const artifactIds = await getArtifactIdsForWorkflowRun(artifactName)
    if (artifactIds.length > 0) {
        for (const artifactId of artifactIds) {
            // Download artifact
            await downloadArtifact(artifactName, artifactId, develocityDir)
        }
    }

    return artifactIds
}

export async function downloadArtifact(artifactName: string, artifactId: number, downloadDir: string): Promise<void> {
    try {
        const archiveName = `${artifactName}.${ZIP_EXTENSION}`

        // Download the Build Scan artifact
        core.debug(`Downloading artifact ${artifactId}`)
        const download = await getOctokit().rest.actions.downloadArtifact({
            owner: github.context.repo.owner,
            repo: github.context.repo.repo,
            artifact_id: artifactId,
            archive_format: ZIP_EXTENSION
        })
        if (download && download.data) {
            // Write artifact
            core.debug(`Writing data to ${archiveName}`)
            io.writeFileSync(downloadDir, archiveName, download.data as ArrayBuffer)

            // Expand archive
            core.debug(`Extracting to ${downloadDir}`)
            const extracted = await io.extractZip(archiveName, downloadDir)
            if (core.isDebug()) {
                core.debug(`Extracted Build Scan artifact to ${extracted}: ${io.readdirSync(extracted)}`)
            }
        } else {
            core.warning(`Unable to download artifact ${artifactId}`)
        }
    } catch (error) {
        const typedError = error as OctokitResponse<unknown>
        if (typedError && typedError.status === 410) {
            core.debug(`Artifact deleted or expired`)
        } else {
            throw error
        }
    }
}

function getBuildScanArtifactIds(artifactName: string, artifacts: Artifact[]): number[] {
    return artifacts
        .filter((candidate: any) => {
            return candidate.name.startsWith(artifactName)
        })
        .map((match: any) => {
            return match.id
        })
}

export async function deleteWorkflowArtifacts(artifactIds: number[]): Promise<void> {
    for (const artifactId of artifactIds) {
        core.debug(`Deleting artifact with id ${artifactId}`)
        await getOctokit().rest.actions.deleteArtifact({
            owner: github.context.repo.owner,
            repo: github.context.repo.repo,
            artifact_id: artifactId
        })
    }
}

export async function commentPullRequest(prNumber: number, htmlSummary: string): Promise<void> {
    const comment = `
${htmlSummary}

${COMMENT_SIGNATURE}
`

    const commentId = await getSummaryComment(prNumber)
    if (commentId) {
        core.debug(`Updating comment`)
        await getOctokit().rest.issues.updateComment({
            owner: github.context.repo.owner,
            repo: github.context.repo.repo,
            comment_id: commentId,
            body: comment
        })
    } else {
        core.debug(`Creating comment`)
        await getOctokit().rest.issues.createComment({
            owner: github.context.repo.owner,
            repo: github.context.repo.repo,
            issue_number: prNumber,
            body: comment
        })
    }
}

async function getSummaryComment(prNumber: number): Promise<number | undefined> {
    try {
        const response = await getOctokit().rest.issues.listComments({
            owner: github.context.repo.owner,
            repo: github.context.repo.repo,
            issue_number: prNumber
        })

        const matchingComment = response.data.find(
            comment => comment && comment.body && comment.body.includes(COMMENT_SIGNATURE)
        )

        return matchingComment?.id
    } catch (error) {
        throw new Error(`Error retrieving comments from PR ${prNumber}: ${error}`)
    }
}

export async function addSummary(title: string, summary: string): Promise<void> {
    core.summary.addHeading(title, 3)
    if (github.context.payload.workflow_run?.id) {
        core.summary.addLink(
            'Origin Workflow',
            `https://github.com/${github.context.repo.owner}/${github.context.repo.repo}/actions/runs/${github.context.payload.workflow_run.id}`
        )
    }
    core.summary.addRaw(summary)
    await core.summary.write()
}

export function logOriginWorkflowLink(): void {
    if (github.context.payload.workflow_run?.id) {
        core.info(
            `Publishing Build ScansÂ® for origin workflow: https://github.com/${github.context.repo.owner}/${github.context.repo.repo}/actions/runs/${github.context.payload.workflow_run.id}`
        )
    }
}
