import * as github from '@actions/github'
import {GitHub} from '@actions/github/lib/utils'
import {OctokitResponse} from '@octokit/types' // eslint-disable-line import/named
import * as core from '@actions/core'
import {Artifact, DefaultArtifactClient} from '@actions/artifact'

import * as input from '../input'
import * as io from '../../io'

const ZIP_EXTENSION = 'zip'

const COMMENT_SIGNATURE = '###### Generated by gradle/github-actions'

export function getOctokit(): InstanceType<typeof GitHub> {
    return github.getOctokit(input.getGithubToken())
}

export function isPublicationAllowed(): boolean {
    return isEventSupported() && isUserAuthorized()
}
function isEventSupported(): boolean {
    return github.context.eventName === 'workflow_run' || isUnderTest()
}

function isUnderTest(): boolean {
    // Some end-to-end tests are run on the pull_request workflow and requires some special treatment
    return github.context.eventName === 'pull_request' && (github.context.repo.owner === 'gradle' && github.context.repo.repo === 'github-actions')
}

function getRunActor(): string {
    return isUnderTest() ? getRunActorForTest() : getRunActorForWorkflowRun()
}

function getRunActorForWorkflowRun(): string {
    return github.context.payload.workflow_run.actor.login
}

function getRunActorForTest(): string {
    return github.context.actor
}

function getListArtifactsOptions(): any {
    return isUnderTest() ? getListArtifactsOptionsForTest() : getListArtifactsOptionsForWorkflowRun()
}

function getListArtifactsOptionsForWorkflowRun(): any {
    const runId = github.context.payload.workflow_run.id

    return {
        findBy: {
            token: input.getGithubToken(),
            workflowRunId: runId,
            repositoryName: github.context.repo.repo,
            repositoryOwner: github.context.repo.owner
        }
    }
}

function getListArtifactsOptionsForTest(): any {
    return {
        latest: true
    }
}

export async function getArtifactIdsForWorkflowRun(artifactName: string): Promise<number[]> {
    const artifactClient = new DefaultArtifactClient()

    const artifacts = await artifactClient.listArtifacts(
        getListArtifactsOptions()
    )

    return getBuildScanArtifactIds(artifactName, artifacts?.artifacts)
}

function isUserAuthorized(): boolean {
    const authorizedUsersList = input.getAuthorizedUsersList().trim()
    const prSubmitter = getRunActor()

    core.debug(`prSubmitter = ${prSubmitter}`)
    if (authorizedUsersList && !authorizedUsersList.split(',').includes(prSubmitter)) {
        core.info(`user ${prSubmitter} not authorized to publish Build Scans`)
        return false
    }

    return true
}

export async function extractArtifactToDirectory(artifactName: string, artifactId: number, folderName: string): Promise<void> {
    try {
        const archiveName = `${artifactName}.${ZIP_EXTENSION}`

        // Download the Build Scan artifact
        core.debug(`Downloading artifact ${artifactId}`)
        const download = await getOctokit().rest.actions.downloadArtifact({
            owner: github.context.repo.owner,
            repo: github.context.repo.repo,
            artifact_id: artifactId,
            archive_format: ZIP_EXTENSION
        })
        if (download && download.data) {
            // Create Build Scan directory
            if (!io.existsSync(folderName)) {
                core.debug(`Creating ${folderName}`)
                io.mkdirSync(folderName)
            }

            // Write artifact
            core.debug(`Writing data to ${archiveName}`)
            io.writeFileSync(folderName, archiveName, download.data as ArrayBuffer)

            // Expand archive
            core.debug(`Extracting to ${folderName}`)
            const extracted = await io.extractZip(archiveName, folderName)
            if (core.isDebug()) {
                core.debug(`Extracted Build Scan artifact to ${extracted}: ${io.readdirSync(extracted)}`)
            }
        } else {
            core.warning(`Unable to download artifact ${artifactId}`)
        }
    } catch (error) {
        const typedError = error as OctokitResponse<unknown>
        if (typedError && typedError.status === 410) {
            core.debug(`Artifact deleted or expired`)
        } else {
            throw error
        }
    }
}

function getBuildScanArtifactIds(artifactName: string, artifacts: Artifact[]): number[] {
    return artifacts.filter((candidate: any) => {
        return candidate.name.startsWith(artifactName)
    }).map((match: any) => {
        return match.id
    })
}

export async function deleteWorkflowArtifacts(artifactId: number): Promise<void> {
    core.debug(`Deleting artifact with id ${artifactId}`)
    await getOctokit().rest.actions.deleteArtifact({
        owner: github.context.repo.owner,
        repo: github.context.repo.repo,
        artifact_id: artifactId
    })
}

export async function commentPullRequest(prNumber: number, htmlSummary: string): Promise<void> {
    const comment = `
${htmlSummary}

${COMMENT_SIGNATURE}
`

    const commentId = await getSummaryComment(prNumber)
    if (commentId) {
        core.debug(`Updating comment`)
        await getOctokit().rest.issues.updateComment({
            owner: github.context.repo.owner,
            repo: github.context.repo.repo,
            comment_id: commentId,
            body: comment
        })
    } else {
        core.debug(`Creating comment`)
        await getOctokit().rest.issues.createComment({
            owner: github.context.repo.owner,
            repo: github.context.repo.repo,
            issue_number: prNumber,
            body: comment
        })
    }
}

async function getSummaryComment(prNumber: number): Promise<number | undefined> {
    try {
        const response = await getOctokit().rest.issues.listComments({
            owner: github.context.repo.owner,
            repo: github.context.repo.repo,
            issue_number: prNumber
        })

        const matchingComment = response.data.find(
            comment => comment && comment.body && comment.body.includes(COMMENT_SIGNATURE)
        )

        return matchingComment?.id
    } catch (error) {
        throw new Error(`Error retrieving comments from PR ${prNumber}: ${error}`)
    }
}

export async function addSummary(title: string, summary: string): Promise<void> {
    core.summary.addHeading(title, 3)
    core.summary.addRaw(summary)
    await core.summary.write()
}
